model Coches

-----------Enumerados-----------------
enum TipoRevision{Reparacion, Mantenimiento}
-----------Fin de enumerados----------

class Clock  -- Este es el modelado del tiempo siempre en todos los modelos
  attributes
    NOW : Integer init = 0 -- POSIX representation starting at 0
    resolution: Integer init = 1 
  operations
    tick() 
      begin
        self.NOW := self.NOW + self.resolution
        for o in self.ao do
          o.tick()
        end;
      end
    run (n:Integer)
      begin
        for i in Sequence{1..n} do
          self.tick()
        end;
      end
end

abstract class ActiveObject -- real-time objects (Todos los objetos que variar치n con el tiempo)
  operations
    tick() begin end
end

class Ciudad
attributes
  nombre: String
end

class Viaje
attributes
  fechaSalida : Integer
  fechaLlegada : Integer 
end

class Coche < ActiveObject
attributes
  matricula: String
  marca: String
  fechaMatriculacion : Integer
  kilometrosRecorridos : Integer derive --Atributo detivado -> Suma de los kilometros recorridos en todos los viajes. Se actualiza solo
    self.viaje->select(v | v.fechaLlegada != null).recorrido->sum(r | r.distancia)
  garantia : Boolean  -- Representa si el coche esta en garantia o no
  necesitaMantenimiento : Boolean 
  viajeEnCurso : Boolean init = false
  recorridoEnCurso : Recorrido
  kilometrosViaje : Integer
  velocidad : Integer

  operations
  viaje(Recorrido r)
    begin
      declare v:Viaje;

      viajeEnCurso := true
      recorridoEnCurso := r
      kilometrosViaje := 0
      
      v.fechaInicio = Cock.NOW
      insert(self, v) into Viajar;
      insert(r, v) into RecorridoDelViaje;

      if self.cochesEnCiudad != null then
        delete(self, self.cochesEnCiudad) from UbicacionCoche;
      end;
    end
    
  avanzar()
    begin
      if self.kilometrosViaje + self.velocidad > self.recorridoEnCurso.distancia then
        self.kilometrosRecorridos := self.kilometrosRecorridos + (self.recorridoEnCurso.distancia - self.kilometrosViaje)
        self.kilometrosViaje := self.recorridoEnCurso.distancia
        
        declare viaje: self.viaje -> select(v | v.fechaLlegada == null) --viaje que estamos haciendo
        declare viajeMod: viaje.fechaLlegada := Clock.NOW --viaje con la fecha de llegada modificada
        
        delete(self, viaje) from Viajar;
        insert(self, viajeMod) into Viajar;

        delete(viaje.recorrido, viaje) from RecorridoDelViaje;
        insert(viaje.recorrido, viajeMod) into RecorridoDelViaje;

        insert(self, viaje.recorrido.ciudad2) into UbicacionCoche;
      end;

      else then
        self.kilometrosViaje := self.kilometrosViaje + self.velocidad
        self.kilometrosRecorridos := self.kilometrosRecorridos + self.velocidad
      end;
    end

    pre: self.kilometrosViaje < self.recorridoEnCurso.distancia --llevar menos tiempo de viaje que la distancia del viaje
    post: self.kilometrosViaje = self.kilometrosViaje@pre + self.velocidad 
          or self.kilometrosViaje = self.recorridoEnCurso.distancia

  tick()
    declare ultima_rev: self.revision->select(r | r.fechaFin = revision -> fechaFin -> max());
    declare ultimo_mantenimiento: self.revision->select(r | r.tipo = 'Mantenimiento')->sortedBy(r | r.fechaFin)->last()
    begin

      if self.viajeEnCurso then 
        self.avanzar()
      end;
      
      -- el coche estara en garantia si han pasado menos de 4 a침os desde que se matricul칩 o si le dura la garantia de la ultima revision
      if (Clock.Now - self.fechaMatriculacion < 400) or((type(ultima_rev.taller) = TallerOficial) and (ultima_rev.taller.garantia + ultima_rev.fechaFin) > Clock.NOW) then
        self.garantia := true
      end;
      else then 
        self.garantia := false
      end;

      -- el coche necesitar치 mantenimiento si han pasado mas de 4 a침os desde que se matricul칩 y si ha pasado mas de 1 a침o desde el ultimo mantenimiento
      if (Clock.NOW - self.fechaMatriculacion > 400) and (Clock.NOW - ultimo_mantenimiento.fechaFin > 100) then
        self.necesitaMantenimiento := true
      end;
      else then 
        self.necesitaMantenimiento := false
      end;
end

class Revision
attributes
  fechaInicio: Integer
  fechaFin: Integer
  tipoRevision : TipoRevision

end

abstract class Taller 
end
class TallerOficial < Taller
attributes
  garantia: Integer
end 

class TallerNoOficial < Taller
end

----------Asociaciones---------------

association Time between 
  Clock[1] role clock
  ActiveObject[*] role ao ordered
end

composition TallerOficialEnCiudad between
  Ciudad[1] role ciudadOficial
  TallerOficial[0..1] role tallerOficial
end

composition TallerNoOficialEnCiudad between
  Ciudad[1] role ciudadNoOficial
  TallerNoOficial[0..*] role tallerNoOficial
end

association UbicacionCoche between 
  Ciudad[1] role cochesEnCiudad
  Coche[*] role ubicacion
end

association Viajar between
  Coche[*] role vehiculo
  Viaje[*] role viaje
end

composition RevisionCoche between 
  Coche[1] role coche
  Revision[*] role revision
end
  
association TallerDeRevision between
  Taller[1] role taller
  Revision[*] role revisiones
end

association RecorridoDelViaje between
  Viaje[*] roles viajes
  Recorrido[1] role recorrido
end


----------Fin Asociaciones---------------
----------Clase de Asociaciones---------------

associationclass Recorrido between
  Ciudad [*] role ciudad1
  Ciudad [*] role ciudad2
attributes
  distancia: Integer

----------Fin Clase de Asociaciones---------------


-------------------Invariantes--------------------
constraints
context Ciudad
  -- (1) Cada ciudad est치 separada al menos 5Km una de otra 游녧
  inv CiudadesAlMenos5Km :
    self.recorrido->select(
      r | r.distancia < 5).size() = 0

context Recorrido
  -- (3) El coche realiza un recorrido siempre entre dos ciudades distintas 游녧
  inv CiudadOrigenDistintaCiuddadDestino : 
    Recorrido.allInstances()->forAll(
      c1, c2 | c1 <> c2 implies c1.nombre <> c2.nombre
    )
    
context Revision
  -- (4) Todas las revisiones deben tener lugar despu칠s de que el coche se matricule 游녧
  inv RevisionDespuesDeMatriculacion :
    Revision.allInstances()->forAll(
      r | r.fechaInicio > r.coche.fechaMatriculacion 
    )

context Coche 
  -- (5) Un coche se debe someter a una revisi칩n, como m치ximo, en un momento dado. 游녧
  inv CocheSoloUnaRevisionAlMismoTiempo :
    self.revision->select(r1, r2 | r1.fechaInicio < r2.fechaInicio and r1.fechaFin > r2.fechaInicio).size() = 0
  
  -- (7) Si un coche est치 siendo sometido a una revisi칩n, entonces el coche debe encontrarse en la misma ciudad donde est치 el taller.
  inv CocheEnCiudadDelTaller : 
      let tallerCoche = self.revision->select(r | r.fechaInicio <= Clock.NOW and r.fechaFin > Clock.NOW).taller
      in
      type(tallerCoche) = TallerOficial implies
        tallerCoche.ciudadOficial.nombre = self.cochesEnCiudad.nombre
      else
        tallerCoche.ciudadNoOficial.nombre = self.cochesEnCiudad.nombre
  end

      --? OTRA VERSI칍N QUE HACE QUE EL CODIGO NO SE MUESTRE RARO (NO UTILIZA LET)--
  -- (7) Si un coche est치 siendo sometido a una revisi칩n, entonces el coche debe encontrarse en la misma ciudad donde est치 el taller.
  --inv CocheEnCiudadDelTaller : 
  --  self.revision->select(r | r.fechaInicio <= Clock.NOW and r.fechaFin > Clock.NOW)->forAll(r | 
  --   r.taller.ciudadOficial.nombre = self.viaje->select(v | v.fechaLlegada = null).recorrido.ciudad1.nombre)
      --?----------------------------------------------------------

  -- (8) Si el coche est치 realizando actualmente alg칰n viaje, dicho viaje 칰nicamente tendr치 fecha de salida, pero no de llegada.  
  inv CocheEnViajeSinFechaLlegada :
    self.viajeEnCurso implies self.viaje->sortedBy(v | v.fechaSalida)->last().fechaLlegada = null
  
  --? INVARIANTE 9 HACER CUANDO HAYA MAQUINA DE ESTADOS
  
  -- (10/12) Si el coche ha completado al menos un viaje y no se encuentra viajando, entonces debe encontrarse en la ciudad a la que lleg칩 en su 칰ltimo viaje
  inv CocheEnCiudadDelUltViaje : --! Hay que revisar para hacerlo con el estado
    let al_menos_un_viaje = self.viaje->select(v | v.fechaLlegada != null)->notEmpty()
    in
    let ultimo_recorrido = self.viaje->sortedBy(v | v.fechaSalida)->last()
    in
    (al_menos_un_viaje and not self.viajeEnCurso implies self.cocheEnCiudad.nombre = ultimo_recorrido.ciudad2.nombre)
    or
    (not al_menos_un_viaje and not self.viajeEnCurso implies self.cocheEnCiudad != null) 
      
  -- (11) Un coche no puede realizar dos viajes a la vez
  inv CocheNoPuedeRealizarDosViajes :
    self.viaje->select(v | v.fechaLlegada = null).size() <= 1
  
  -- (12) Si el coche ha realizado un viaje desde la ciudad A a B, el proximo viaje debe empezar en B
  --inv viajeEmpiezaDondeAcaboViajeAnterior : --!PREUNTAR EL LUNES A LOLA
    --let al_menos_un_viaje = self.viaje->select(v | v.fechaLlegada != null)->notEmpty()
    --in
    --let ultimo_recorrido = self.viaje->sortedBy(v | v.fechaSalida)->last()
    --in
    --(al_menos_un_viaje and not self.viajeEnCurso implies self.cocheEnCiudad.nombre = ultimo_recorrido.ciudad2.nombre)
    

















































































































































    