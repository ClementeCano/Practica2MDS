model Coches

-----------Enumerados-----------------
enum TipoRevision{Reparacion, Mantenimiento}
-----------Fin de enumerados----------

class Clock  -- Este es el modelado del tiempo siempre en todos los modelos
  attributes
    NOW : Integer init = 0 -- POSIX representation starting at 0
    resolution: Integer init = 1 
  operations
    tick() 
      begin
        self.NOW := self.NOW + self.resolution
        for o in self.ao do
          o.tick()
        end
      end
    run (n:Integer)
      begin
        for i in Sequence{1..n} do
          self.tick()
        end
      end
end

abstract class ActiveObject -- real-time objects (Todos los objetos que variarán con el tiempo)
  operations
    tick() begin end
end

class Ciudad
attributes
  nombre: String
end

class Viaje
attributes
  fechaSalida : Integer
  fechaLlegada : Integer 
end

class Coche < ActiveObject
attributes
  matricula: String
  marca: String
  fechaMatriculacion : Integer
  kilometrosRecorridos : Integer derive --Atributo detivado -> Suma de los kilometros recorridos en todos los viajes. Se actualiza solo
    self.viaje->select(v | v.fechaLlegada != null).recorrido->sum(r | r.distancia)
  tieneGarantia : Boolean derive -- Representa si el coche esta en garantia o no
    (Clock.NOW - self.fechaMatriculacion < 400) or 
      (self.revision->select(r | r.taller = TallerOficial)->sortedBy(r | r.fechaFin)->last().garantia + 
        self.revision->select(r | r.taller = TallerOficial)->sortedBy(r | r.fechaFin)->last().fechaFin > Clock.NOW)
  necesitaMantenimiento : Boolean derive -- Representa si el coche necesita mantenimiento o no
    (Clock.NOW - self.fechaMatriculacion > 400) and (Clock.NOW - (self.revision->select(r | r.tipo = 'Mantenimiento')->sortedBy(r | r.fechaFin)->last()).fechaFin > 100) --? Comprobar el .fechaFin
  kilometrosViaje : Integer
  velocidad : Integer

-- recorrido y viaje en curso lo hemos eliminado, cuidado en las invariantes
-- necesitaMantenimiento y tieneGarantia le cambiemos el nombre

  operations
  viaje(r:Recorrido)
    begin
      declare v:Viaje;

      self.kilometrosViaje := 0
      
      v.fechaInicio = Clock.NOW
      insert(self, v) into Viajar;
      insert(r, v) into RecorridoDelViaje;

      if self.cochesEnCiudad != null then
        delete(self, self.cochesEnCiudad) from UbicacionCoche;
      end;
    end
    
    pre: self.viaje -> select(via| via.fechaLlegada = null) -> Empty()
    post: self.kilometrosViaje = 0
          and self.recorridoEnCurso <> null


  avanzar()
    begin
      declare viaje: self.viaje -> select(v | v.fechaLlegada = null) --viaje que estamos haciendo
      declare viajeMod: viaje.fechaLlegada := Clock.NOW --viaje con la fecha de llegada modificada
      declare distancia: viaje.recorrido.distancia

      if self.kilometrosViaje + self.velocidad >= distancia then
        self.kilometrosRecorridos := self.kilometrosRecorridos + (distancia - self.kilometrosViaje)
        self.kilometrosViaje := distancia


        delete(self, viaje) from Viajar;
        insert(self, viajeMod) into Viajar;

        delete(viaje.recorrido, viaje) from RecorridoDelViaje;
        insert(viaje.recorrido, viajeMod) into RecorridoDelViaje;

        insert(self, viaje.recorrido.ciudad2) into UbicacionCoche;
        
      else
        self.kilometrosViaje := self.kilometrosViaje + self.velocidad
        self.kilometrosRecorridos := self.kilometrosRecorridos + self.velocidad
      end;
    end

    pre: self.kilometrosViaje < distancia --llevar menos tiempo de viaje que la distancia del viaje
    post: self.kilometrosViaje = self.kilometrosViaje@pre + self.velocidad 
          or self.kilometrosViaje = distancia 

  tick()
    declare viajeEnCurso: self.viaje -> select(v| v.fechaLlegada = null)
    begin
      if viajeEnCurso then 
        self.avanzar()
      end;
end

class Revision
attributes
  fechaInicio: Integer
  fechaFin: Integer
  tipoRevision : TipoRevision

end

abstract class Taller 
end
class TallerOficial < Taller
attributes
  garantia: Integer
end 

class TallerNoOficial < Taller
end

----------Asociaciones---------------

association Time between 
  Clock[1] role clock
  ActiveObject[*] role ao ordered
end

composition TallerOficialEnCiudad between
  Ciudad[1] role ciudadOficial
  TallerOficial[0..1] role tallerOficial
end

composition TallerNoOficialEnCiudad between
  Ciudad[1] role ciudadNoOficial
  TallerNoOficial[0..*] role tallerNoOficial
end

association UbicacionCoche between 
  Ciudad[1] role cochesEnCiudad
  Coche[*] role ubicacion
end

association Viajar between
  Coche[*] role vehiculo
  Viaje[*] role viaje
end

composition RevisionCoche between 
  Coche[1] role coche
  Revision[*] role revision
end
  
association TallerDeRevision between
  Taller[1] role taller
  Revision[*] role revisiones
end

association RecorridoDelViaje between
  Viaje[*] roles viajes
  Recorrido[1] role recorrido
end


----------Fin Asociaciones---------------
----------Clase de Asociaciones---------------

associationclass Recorrido between
  Ciudad [*] role ciudad1
  Ciudad [*] role ciudad2
attributes
  distancia: Integer

----------Fin Clase de Asociaciones---------------

-------------------Invariantes--------------------
constraints
context Ciudad
  -- (1) Cada ciudad está separada al menos 5Km una de otra 
  inv CiudadesAlMenos5Km :
    self.recorrido->select(r | r.distancia < 5).size() = 0

context Recorrido
  -- (3) El coche realiza un recorrido siempre entre dos ciudades distintas 
  inv CiudadOrigenDistintaCiuddadDestino : 
    Recorrido.allInstances()->forAll(c1, c2 | c1 <> c2 implies c1.nombre <> c2.nombre)
    
context Revision
  -- (4) Todas las revisiones deben tener lugar después de que el coche se matricule 
  inv RevisionDespuesDeMatriculacion :
    Revision.allInstances()->forAll(r | r.fechaInicio > r.coche.fechaMatriculacion)

context Coche 
  -- (5) Un coche se debe someter a una revisión, como máximo, en un momento dado. 
  inv CocheSoloUnaRevisionAlMismoTiempo :
    self.revision->select(r1, r2 | r1.fechaInicio < r2.fechaInicio and r1.fechaFin > r2.fechaInicio).size() = 0
  
  --! (7) Si un coche está siendo sometido a una revisión, entonces el coche debe encontrarse en la misma ciudad donde está el taller.   CREO QUE YA ESTA BIEN REVISAR
  inv CocheEnCiudadDelTaller : 
      let tallerCoche = self.revision->select(r | r.fechaInicio <= Clock.NOW and r.fechaFin > Clock.NOW).taller
      in
      not exist(tallerCoche) implies true
      or
      type(tallerCoche) = TallerOficial implies tallerCoche.ciudadOficial = self.cochesEnCiudad
      or
      type(tallerCoche) <> TallerOficial implies tallerCoche.ciudadNoOficial = self.cochesEnCiudad

  -- (8) Si el coche está realizando actualmente algún viaje, dicho viaje únicamente tendrá fecha de salida, pero no de llegada.  
  inv CocheEnViajeSinFechaLlegada :
    let viajeEnCurso = (self.viaje -> select(v | v.fechaSalida = null)) = 1
    in
    viajeEnCurso implies self.viaje->sortedBy(v | v.fechaSalida)->last().fechaLlegada = null
  
  -- (9) Un coche se encontrará en todo momento bien realizando un viaje determinado o bien en una ciudad.
  inv CocheViajandoOEnCiudad :
    let viajeEnCurso = (self.viaje -> select(v | v.fechaSalida = null)) = 1
    in
    (viajeEnCurso implies self.cocheEnCiudad = null)
    or
    (not viajeEnCurso implies self.cocheEnCiudad <> null)
   
  
  -- (10/12) Si el coche ha completado al menos un viaje y no se encuentra viajando, entonces debe encontrarse en la ciudad a la que llegó en su último viaje
  inv CocheEnCiudadDelUltViaje : 
    let al_menos_un_viaje = self.viaje->select(v | v.fechaLlegada <> null)->notEmpty()
    in
    let ultimo_recorrido = self.viaje->sortedBy(v | v.fechaSalida)->last()
    in
    let viajeEnCurso = (self.viaje -> select(v | v.fechaSalida = null)) = 1
    in
    (al_menos_un_viaje and not viajeEnCurso implies self.cocheEnCiudad = ultimo_recorrido.recorrido.ciudad2)
    or
    (not al_menos_un_viaje and not viajeEnCurso implies self.cocheEnCiudad <> null) 
      
  -- (11) Un coche no puede realizar dos viajes a la vez
  inv CocheNoPuedeRealizarDosViajes :
    self.viaje->select(v | v.fechaLlegada = null).size() <= 1
  
  -- (15) Si un coche está en garantía, entonces la fecha de matriculación del coche no puede superar los 400 días o la fecha de fin de la última revisión oficial más la garantía del taller oficial debe ser mayor que la fecha actual
  inv CocheTieneGarantia :
    let ultima_revision_oficial = self.revision->select(r | r.taller = TallerOficial)->sortedBy(r | r.fechaFin)->last()
    in
    self.tieneGarantia = true implies 
      (Clock.NOW - self.fechaMatriculacion < 400) or (ultima_revision_oficial.taller.garantia + ultima_revision_oficial.fechaFin > Clock.NOW)
  
  -- (16) Si un coche necesita mantenimiento, entonces la fecha de matriculación del coche debe superar los 400 días y la fecha de fin de la última revisión de mantenimiento más 100 días debe ser menor que la fecha actual
  inv CocheNecesitaMantenimiento :
    self.necesitaMantenimiento = true implies
      (Clock.NOW - self.fechaMatriculacion > 400) and (Clock.NOW - (self.revision->select(r | r.tipo = 'Mantenimiento')->sortedBy(r | r.fechaFin)->last()).fechaFin > 100) --? Comprobar el .fechaFin


  context Clock
  -- Sólo puede haber un reloj en el sistema
  inv UnSoloReloj:
    Clock.allInstances() -> size() = 1

